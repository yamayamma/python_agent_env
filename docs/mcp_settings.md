統合エディタールール管理MCPサーバーの構築に向けた技術調査報告書はじめに：エージェントワークフローにおける一元的なルール管理の必要性近年のソフトウェア開発現場では、Claude Code、Cline、Roo Codeをはじめとする多様なAIコーディングアシスタントの導入が進んでいます 1。開発者やチームは、個々の好みや特定のタスクへの適合性に基づき、異なるツールを選択しています。この状況は、コーディング規約、セキュリティポリシー、プロジェクト固有の慣習といった開発標準を組織全体で一貫して適用する上で、大きな課題を生み出しています。各ツールが独自のルール管理システム（例えば、Claude CodeのCLAUDE.md 4、Clineの.clinerules 5、Roo Codeの.roo/rules/ 6）を持つため、開発環境は断片化しがちです。この「ガバナンスの隙間」は、ルールの重複設定、開発標準の更新・展開の遅延、そして最終的にはAIアシスタントの挙動の不整合といった問題を引き起こします。これらの課題を解決するため、本報告書では、一元管理を実現するModel Context Protocol（MCP）サーバーの構築を提案します。このサーバーは、開発標準に関する「信頼できる唯一の情報源（Single Source of Truth）」として機能します。様々なAIエージェントからのリクエストを受け取り、接続元のエディタを識別し、そのエディタに特化した設定指示（例えば、「CLAUDE.mdを作成・追記する」）をプログラム的にディスパッチします。このアプローチにより、AI支援開発ワークフローの管理を中央集権化し、一貫性を確保し、運用を簡素化することが可能となります。本報告書は、まずClaude Code、Cline、Roo Codeという3つの主要なAIアシスタントにおけるルール管理の仕組みを詳細に分析します。次に、これらの分析結果を一般的なエディタの設計パターンと統合し、知見を抽出します。最終的に、これらの調査結果に基づき、提案するMCPサーバーの具体的なアーキテクチャ設計図を提示することを目的とします。Claude Codeにおけるプログラム的なルール管理の詳細Claude Codeは、その柔軟性とプログラムからの高いアクセス性を特徴とし、成熟したAIツールとしての基準を示しています。ルール管理は主に、CLAUDE.mdという特殊なコンテキストファイルと、強力なコマンドラインインターフェース（CLI）および公式SDKを介して行われます。CLAUDE.mdコンテキストファイル：構造、配置、優先順位CLAUDE.mdは、Claude Codeが対話を開始する際に自動的に読み込む特別なファイルであり、プロジェクト固有のコンテキストを提供するための中心的なメカニズムです 4。コア機能と設計思想このファイルの設計思想は、意図的に「低レベルで、特定の意見に固執しない（low-level and unopinionated）」ものであり、厳格な構造を強制するのではなく、柔軟性を最大限に高めることを目的としています 4。これにより、開発者はプロジェクトのニーズに合わせて自由な形式でコンテキストを記述できます。主な用途としては、技術スタックの概要、プロジェクトのディレクトリ構造、頻繁に使用するシェルコマンド、コードスタイルガイドライン、テスト手順などが挙げられます 4。内容とフォーマットCLAUDE.mdには必須のフォーマットは存在しません 4。内容は自由形式のMarkdownファイルとして記述されます。ただし、AIと人間の両方が解読しやすいように、標準的なMarkdownの見出し（#, ##など）を用いて論理的なセクションに分割することがベストプラクティスとして推奨されています 7。例えば、「Tech Stack」「Project Structure」「Commands」「Code Style」といったセクションを設けることで、情報の整理が容易になります 7。ファイルの配置と優先順位Claude Codeは、階層的な探索システムを用いてCLAUDE.mdファイルを読み込みます。この探索は、カレントディレクトリから始まり、親ディレクトリを再帰的に遡って行われます。また、ユーザーのホームディレクトリ（~/.claude/CLAUDE.md）も探索対象に含まれます 4。これにより、プロジェクト固有の設定、モノレポ全体の設定、そしてユーザー個人のグローバルな設定といった、階層的な設定の重ね合わせが可能になります。さらに、CLAUDE.local.mdという名前のファイルを作成することで、Gitの管理対象から除外されるローカル専用のオーバーライド設定を定義することもできます 4。この優先順位と階層構造を理解することは、MCPサーバーがルールを適用する際に、意図した通りのコンテキストが反映されることを保証する上で極めて重要です。コマンドラインインターフェース（CLI）によるルールの初期化と対話Claude CodeのCLIは、ルールの初期設定と対話的な改善を行うための主要なインターフェースです。インストールと初期化CLIは、Node Package Manager（npm）を介してグローバルにインストールされます：npm install -g @anthropic-ai/claude-code 8。インストール後、プロジェクトのルートディレクトリで/initコマンドを実行することが、ルール定義の第一歩となります 8。このコマンドは、プロジェクトの基本的な情報を読み取り、定型的なCLAUDE.mdファイルを自動生成します 7。これにより、開発者はゼロから始めることなく、効率的にルール定義を開始できます。対話的なルール改善コーディングセッション中に#キーを使用すると、Claudeに対して指示を与え、その内容を関連するCLAUDE.mdファイルに自動的に追記させることができます 4。これはユーザー向けの機能ですが、ルールファイルが一度設定して終わりではなく、開発プロセスを通じて継続的に改善されていく「生きたドキュメント」であることを示唆しています。非対話的な実行プログラムからの制御において最も重要なのが、-p（または--print）フラグです 11。このフラグを使用すると、Claude Codeは単一のプロンプトを実行して結果を出力した後に終了します。これは、MCPサーバーが特定のタスク（例：「この内容でCLAUDE.mdを更新せよ」）を一度だけ実行させたい場合に不可欠なメカニズムです。Claude Code SDK：プログラム制御へのゲートウェイ公式に提供されているSDKは、Claude Codeを他のアプリケーションやサービスに統合するための最も強力かつ安定した手段です。概要と利用可能性Claude Code SDKは、TypeScriptとPython向けに提供されており、Claude Codeをサブプロセスとして実行することを可能にします 11。これにより、カスタム開発ツールや自動化ワークフローの構築が容易になります。この公式SDKの存在は、他のツールと比較してClaude Codeが持つ大きな利点です。認証SDKは複数の認証方法をサポートしており、本番環境のサーバーで利用する上で堅牢なセキュリティ基盤を提供します。Anthropic APIキー: ANTHROPIC_API_KEY環境変数を設定します 11。Amazon Bedrock: CLAUDE_CODE_USE_BEDROCK=1環境変数を設定し、AWSの認証情報を構成します 11。Google Vertex AI: CLAUDE_CODE_USE_VERTEX=1環境変数を設定し、Google Cloudの認証情報を構成します 11。プログラムによるファイルとルールの操作MCPサーバーのClaudeCodeHandlerがルールを操作する際の中心的な機能は、SDKのquery()関数です 11。この関数はプロンプトとオプションを引数に取り、Claude Codeにタスクを実行させます。ルールファイルを自動で変更するためには、allowed_toolsオプションでファイル操作（Read, Write）やシェルコマンド（Bash）の実行を許可し、permission_modeオプションで対話的な許可プロンプトをバイパスする必要があります 11。以下に、Python SDKを使用したCLAUDE.mdファイルの作成例を示します。Pythonfrom claude_code_sdk import query, ClaudeCodeOptions
from pathlib import Path

# MCPサーバーがターゲットプロジェクトのパスを指定
target_project_path = "/path/to/target/project"
# 作成したいルールの内容
rule_content = """
# Project Structure
- `src/`: Source code
- `tests/`: Unit tests

# Code Style
- Use TypeScript.
- Follow Prettier for formatting.
"""

# SDKのオプションを設定
options = ClaudeCodeOptions(
    cwd=Path(target_project_path),
    allowed_tools=["Write"],  # ファイル書き込みを許可
    permission_mode="acceptEdits"  # 編集の許可プロンプトを自動で承認
)

# プロンプトを構築して実行
prompt = f"Create a new file named CLAUDE.md with the following content:\n\n{rule_content}"

async def create_rule_file():
    async for message in query(
        prompt=prompt,
        options=options
    ):
        if message.type == 'assistant':
            # 実行結果の確認
            print(message.content)

# 実行
import anyio
anyio.run(create_rule_file)
このコードは、MCPサーバーがCLAUDE.mdファイルをプログラム的に、かつ非対話的に作成するための具体的で信頼性の高い方法を示しています。.claude/commands/によるカスタムコマンドの定義ユーザーは、プロジェクトのルートまたはホームディレクトリにある.claude/commands/ディレクトリ内にMarkdownファイルを作成することで、カスタムスラッシュコマンドを定義できます 4。ファイル名がそのままコマンド名になります（例：deploy.mdは/deployコマンドとなる）。この機能はMCPサーバーにとっても有用です。サーバーは、例えば「/apply-corporate-standards」というコマンドファイルをプログラム的に生成できます。このファイルには、「中央リポジトリから最新のルールを取得し、現在のプロジェクトに適用せよ」といった内容のプロンプトを記述しておくことができます。これにより、開発者は簡単なコマンド一つで、標準化されたルールセットを自身の環境に適用できるようになります。考察と示唆Claude Codeの分析から得られる最も重要な点は、公式にサポートされた堅牢なSDKの存在です 11。このSDKは、安定的で抽象化されたプログラムインターフェースを提供し、MCPサーバーのような外部ツールがClaude Codeを制御するための信頼性の高い基盤となります。この事実は、MCPサーバーのアーキテクチャ設計に直接的な影響を与えます。信頼性の高いサーバーを構築するには、制御対象となるエディタとのインターフェースが安定している必要があります。Claude Codeは公式SDKを提供しており、これはベンダーによる後方互換性や継続的なメンテナンスがある程度期待できることを意味します。対照的に、後述するClineやRoo Codeは、ファイルシステムへの直接的な操作やコミュニティベースの非公式ツールに依存しており、本質的に不安定さを内包しています 6。したがって、MCPサーバー内に実装されるClaudeCodeHandlerは、他のエディタのハンドラと比較して、本質的により堅牢で、将来的なエディタのアップデートによる破損のリスクが低くなります。このことから、MCPサーバーのアーキテクチャは、ClaudeCodeHandlerを「ゴールドスタンダード」として位置づけるべきです。そして、他のエディタ用のハンドラは、この安定したインターフェースを模倣するような抽象化層を設けることで、内部的に高い運用リスクを管理する設計が求められます。Clineのファイル中心ルールシステムの解体Clineのルール管理システムは、Claude Codeとは対照的に、公式なAPIやSDKではなく、ファイルシステムの規約に基づいている点が最大の特徴です。このアプローチは、外部ツール（本件におけるMCPサーバー）に、正当性や原子性の担保という点でより大きな責任を課します。ワークスペースルール vs グローバルルール：.clinerulesシステムClineは、プロジェクトのルートに配置された.clinerulesファイルまたは.clinerules/ディレクトリを使用して、ワークスペース固有のルールを管理します 5。これに加えて、ユーザーレベルのグローバルルールは、特定のユーザーディレクトリ（例：Documents/Cline/Rules）に保存されます 5。.clinerules/ディレクトリが使用される場合、Clineはその内部にある全ての.mdファイルを読み込み、それらを一つの統合されたコンテキストとして扱います 5。この仕組みにより、ルールを機能ごとにモジュール化して管理することが可能になります（例：01-coding-standards.md、02-documentation-policy.md）。ルールのフォーマットと構造ルールは、Claude CodeのCLAUDE.mdと同様に、シンプルなMarkdown形式で記述されます 5。特定のフロントマターや厳格な構造は要求されず、開発者はMarkdownの見出しを使って自由にルールを構成できます。効果的なルールを作成するための指針として、明確かつ簡潔であること、具体的な手順ではなく期待される結果に焦点を当てること、そして試行錯誤を繰り返して改善していくことが推奨されています 5。「ルールバンク」パターン：ユーザー主導のワークフローClineのドキュメントでは、「ルールバンク（clinerules-bank/）」という興味深いベストプラクティスが紹介されています 5。これは、バージョン管理下に置かれた、利用可能だが非アクティブなルールのリポジトリです。開発者は、現在のタスクやクライアントの要件に応じて、この「バンク」から必要なルールファイルをアクティブな.clinerules/ディレクトリにコピーするためのスクリプトを作成します。このユーザー主導のパターンは、本調査の目的であるMCPサーバーのコンセプトの正当性を裏付ける強力な証拠となります。つまり、アクティブなルールセットを動的かつプログラム的に管理したいという明確なニーズが開発者コミュニティに存在しており、MCPサーバーはまさにそのニーズを、より自動化され、中央集権的な方法で満たすことを目指しているのです。プログラムによるアクセス：ファイルシステム操作と非公式CLI主要な方法：ファイルI/Oルールを管理するための主要かつ公式に文書化されている方法は、.clinerules/ディレクトリ内のMarkdownファイルを作成、削除、または変更することです 5。したがって、MCPサーバーのClineHandlerは、このファイル操作ロジックを中心に構築されなければなりません。非公式CLIツール（@yaegaki/cline-cli）コミュニティによって開発された非公式のCLIツール（@yaegaki/cline-cli）が存在します 13。このツールはnpmを介してインストールされ、cline-cli task "your task"のようなコマンドでClineにタスクを実行させることができます。設定ファイルは~/.cline_cli/cline_cli_settings.jsonに保存されます 13。しかし、このCLIはあくまでClineにタスクを実行させるためのものであり、.clinerulesファイルを直接管理するためのものではありません。タスクとして「.clinerulesファイルを作成せよ」と指示することは可能ですが、MCPサーバーにとっては、ファイルシステムを直接操作する方がより直接的で確実です。この非公式ツールに依存することは、不要かつ不安定な依存関係をシステムに持ち込むことになるため、推奨されません。考察と示唆Clineのルールシステムは、公式なAPIではなく、ファイルシステムの規約に根本的に依存しています。この事実は、システムの挙動を制御する外部ツール、すなわち我々が設計するMCPサーバーに、より大きな責任を負わせることを意味します。Clineの挙動は、特定のディレクトリ（.clinerules/）に存在するファイルの内容によって決定されます 5。「ルールXを有効化する」といった操作を行うための公式SDKやAPIは存在せず、文書化された方法は対応する.mdファイルをディレクトリに追加・削除することです。このため、MCPサーバーのClineHandlerは、APIを呼び出すのではなく、ターゲットマシンのワークスペース上でファイルシステムの操作（作成、書き込み、削除）を実行する必要があります。ファイルシステム操作はアトミックではありません。サーバーからの書き込み処理が途中で失敗した場合、不完全または破損したルールファイルが残される可能性があります。したがって、サーバーはトランザクションの安全性を確保するための独自のロジック（例：一時ファイルへの書き込み後、リネームする）を実装する必要があります。これは、詳細な操作を抽象化してくれるClaude CodeのSDKとは著しい対照をなしています。結論として、MCPサーバー内のClineHandlerは、ClaudeCodeHandlerよりも複雑で「脆く（brittle）」なる可能性が高いと言えます。ファイルパスの解決、パーミッションの管理、トランザクション的な書き込み処理など、より多くの低レベルな詳細を扱う必要があり、将来のClineのアップデートでディレクトリ構造やファイル読み込みロジックが変更された場合に破損するリスクも高まります。アーキテクチャは、この高い運用リスクを前提として設計されなければなりません。Roo Codeのモード特化型設定フレームワークの分析Roo Codeは、Clineから派生したツールであり 15、そのルール管理システムは、ファイル中心のアプローチを継承しつつも、より構造化されたフレームワークへと進化しています。このセクションでは、その特徴的なメカニズムを分析します。TOML+MDフォーマットによる詳細なルール定義Roo Codeは、ルールファイルにTOML+MDという、よりフォーマルなフォーマットを導入しています 6。TOMLフロントマター: ファイルの先頭部分には、TOML（Tom's Obvious, Minimal Language）形式で記述されたメタデータが含まれます。ここには、id、title、scope、statusといった、ルールに関する構造化された情報が格納されます 6。これにより、ClineやClaude Codeの自由形式Markdownと比較して、ルールプロパティの機械的な可読性とクエリ可能性が大幅に向上します。Markdownボディ: フロントマターに続く部分には、他のツールと同様に、人間が読むためのルール指示がMarkdown形式で記述されます 6。ワークスペースルールとモード特化型ルールの区別Roo Codeのルールシステムは、適用のスコープによって明確に区別された2層構造を持っています。ワークスペースルール: プロジェクトのルートにある.roo/rules/ディレクトリに配置され、そのワークスペース内で動作する全ての「モード」に対してグローバルに適用されます 6。これらは、コミットメッセージの標準やOSを意識したコマンドの使用など、プロジェクトの基本的な規約を定義するために使用されます。モード特化型ルール: .roo/rules-[mode_slug]/（例：.roo/rules-dev-react/）という形式のディレクトリに配置され、特定のモードがアクティブな場合にのみ適用されます 6。この「モード」という概念はRoo Codeの強力な特徴であり、「ペアプログラマーモード」や「ドキュメンターモード」といった、タスクに応じたAIのペルソナや挙動の切り替えを可能にします 16。ルールの読み込み順序と優先順位ルールがLLMのコンテキストに注入される順序は明確に定義されています： 1) モードの基本system_prompt、2) ワークスペースルール（.roo/rules/）、3) モード特化型ルール（.roo/rules-[mode_slug]/）の順です 6。この階層構造は、MCPサーバーがルールを注入する際に、既存のルールとどのように相互作用するかを理解する上で不可欠です。後から読み込まれるモード特化型ルールは、より広範なワークスペースルールを補完、あるいは慎重に記述すれば上書きすることも可能です。主要な設定方法：直接的なファイルシステム操作Clineと同様に、Roo Codeのルールを管理するための公式なSDKや専用CLIの存在は確認できませんでした。調査結果は、設定の唯一の方法がファイルシステムの直接操作であることを示唆しています 6。したがって、MCPサーバーのRooCodeHandlerは、TOML+MDファイルを解析・生成し、それらを正しいディレクトリ（.roo/rules/または.roo/rules-[mode_slug]/）に配置するロジックを実装する必要があります。考察と示唆Roo Codeは、ファイルベースのルールパターンの進化形と見なすことができます。より多くの構造（TOML+MD）と、形式化されたコンテキスト切り替えメカニズム（「モード」）を導入したことは、エージェントツール分野における重要な成熟の兆候です。これは、純粋で非構造的なコンテキストだけでは、複雑で役割に基づいたタスクを実行するには不十分であるという、市場の認識の変化を反映しています。この進化の過程を考察すると、以下の点が明らかになります。Roo CodeはClineのフォークまたは後継として登場しました 15。ClineはプレーンなMarkdownファイルとシンプルな.clinerules/ディレクトリを使用していました 5。Roo Codeは、ルールにメタデータを付与するためのTOMLフロントマターと、タスクに応じてルールセット全体を容易に切り替えるための「モード」という概念を導入しました 6。この進化は、開発者がより高度な機能を求めていたことを示唆しています。彼らは単にルールを設定するだけでなく、ルールにメタデータを付け、タスクコンテキストに応じてルールセット全体を動的に切り替えたいと考えていたのです。この事実は、MCPサーバーの設計に重要な示唆を与えます。サーバーは、単一のルールを作成する単純なコマンド（例：createRule）だけでなく、「ルールセット」や「プロファイル」といった概念をサポートすべきです。これらをアトミックに適用できる機能は、Roo Codeが示したような、より高度な開発者のニーズに応えるものとなります。したがって、MCPサーバーの内部的なルール表現は、単なるテキスト文字列ではなく、id、name、description、content、targetEditor、targetModeといったフィールドを持つ構造化されたオブジェクトであるべきです。これにより、サーバーはターゲットエディタに応じて正しい出力フォーマット（.md、TOML+MDなど）をインテリジェントに生成でき、アーキテクチャの将来性を確保することができます。ルール管理メカニズムの比較統合これまでの詳細な分析を基に、各ツールのルール管理メカニズムを比較し、共通のパターンと重要な相違点を抽出します。これらの知見は、汎用性と拡張性に優れたMCPサーバーを設計するための基礎となります。AIアシスタントのルール管理比較以下の表は、Claude Code、Cline、Roo Codeのルール管理における主要な特徴をまとめたものです。この比較により、各ツールに対応するハンドラを設計する際のアーキテクチャ上の決定が明確になります。特徴Claude CodeClineRoo CodeルールファイルCLAUDE.md, CLAUDE.local.md, ~/.claude/CLAUDE.md, .claude/commands/*.md.clinerules, .clinerules/*.md, ~/Documents/Cline/Rules/*.md.roo/rules/*.md, .roo/rules-[mode_slug]/*.mdファイル形式非構造化Markdown非構造化MarkdownTOMLフロントマター + Markdownボディ設定スコープ階層的（グローバル、リポジトリ、サブディレクトリ）グローバル、ワークスペースワークスペース、モード特化型主要なプログラムインターフェース公式SDK (Python/TS), CLI直接的なファイルI/O直接的なファイルI/O二次的インターフェースCLI (claude)非公式CLI (@yaegaki/cline-cli)なし公式サポートのレベル高（ベンダー提供のSDK）低（コミュニティ/ファイルベース）低（ファイルベース）主要な差別化要因SDKを介したエージェント的なツール使用「ルールバンク」パターン、シンプルさ「モード」によるコンテキスト切り替え、TOMLメタデータ全ツールに共通するパターンの特定分析対象のAIアシスタントと従来の汎用エディタには、いくつかの共通した設計思想が見られます。プロジェクトローカル設定: 3つのAIツールすべてが、VS Code (.vscode/settings.json) 17やJetBrains IDE (.idea/) 18といった従来のツールと同様に、プロジェクトのルートに配置されるローカル設定ファイルを強く支持しています 4。これは、設定がコードベースと共に進化することを可能にする基本的な原則であり、MCPサーバーが従うべき重要な指針です。テキストベースでバージョン管理可能なフォーマット: ルールは、人間が判読可能なテキストファイル（Markdown、TOML、JSON、INI、XMLなど）で保存されます 6。これにより、Gitなどのバージョン管理システムでルールの変更履歴を追跡することが容易になり、開発標準の変遷をコードベースの変更と同期させることができます。主要な相違点の明確化最も重大な相違点は、プログラムからのアクセス方法にあります。API 対 ファイルシステムの二分法: Claude Codeは、公式SDKを通じて安定的で抽象化されたAPIを提供します 11。一方で、ClineとRoo Codeは、特定のファイルパスの存在を前提とする「規約（Convention）」に依存しています 5。この違いは、MCPサーバーに実装される各ハンドラの複雑性、信頼性、そして保守性に直接的な影響を及ぼします。APIベースのハンドラは変更に強い一方、ファイルシステムベースのハンドラは、エディタ側の仕様変更によって容易に破損するリスクを抱えています。従来の汎用エディタからの教訓AIアシスタントだけでなく、長年使われてきた汎用エディタの設定方法からも、多くの知見を得ることができます。.editorconfig: シンプルで普遍的な標準（INIライクなフォーマット）と、階層的なファイル探索の力を示しています 20。特に、設定の継承を意図的に停止させるroot = trueという概念は、設定のスコープを明確に区切る上で非常に価値があります。VS Code (settings.json): ユーザー設定とワークスペース設定のスコープが明確に分離された、リッチで構造化された（JSON）設定システムの手本です 17。設定ファイルを直接編集することで挙動を変更できる点は、ClineやRoo Codeのハンドラを実装する上での重要な類似点です。JetBrains (.idea/): 複数のXMLファイルから成る、より複雑なシステムです 18。その強力さとは裏腹に、複雑さとプロプライエタリな性質は、我々が目指すようなクロスプラットフォームツールにとっては、むしろ避けるべき教訓となります。シンプルで透明性の高いフォーマットの方が、相互運用性や保守性の観点から望ましいと言えます。考察と示唆非構造化フォーマット（CLAUDE.md, .clinerules）から構造化フォーマット（TOML付きの.roo/rules）への進化は、市場の成熟を示唆しています。エージェントが実行するタスクが複雑化するにつれて、コンテキストにメタデータや形式的な構造を求めるニーズが高まっています。この傾向は、従来の高度なエディタが、その膨大な機能セットを管理するために、早くからJSONやXMLといった構造化された設定ファイルを採用してきた歴史と一致します 17。このことから、AIエージェントの設定も、将来的にはさらに構造化されたフォーマットへと向かうことが予測されます。この予測は、MCPサーバーの設計に重要な示唆を与えます。サーバーが内部で扱う「ルール」のデータモデルは、単なるテキストの塊ではなく、id、name、content、targetEditorといったフィールドを持つ構造化されたオブジェクトであるべきです。これにより、サーバーはターゲットエディタの要件に応じて、適切なフォーマット（プレーンなMarkdownやTOML+MDなど）を動的に生成することができ、将来的な拡張にも柔軟に対応できるアーキテクチャとなります。統一MCPルールサーバーのアーキテクチャ設計図本セクションでは、これまでの分析に基づき、一元的なルール管理を実現するためのMCPサーバーの具体的な技術設計を提示します。この設計は、信頼性、拡張性、保守性を重視しています。コアサーバーアーキテクチャとエディタ識別技術スタックサーバーの技術スタックとしては、Node.jsとTypeScript、そしてWebフレームワークとしてExpress.jsの組み合わせを提案します。このスタックは、npmやVS Code拡張機能といった関連ツールのエコシステムと親和性が高く、非同期I/O処理に優れているため、複数のエージェントからのリクエストを効率的に捌くのに適しています。エディタ識別問題と解決策サーバーが機能するためには、リクエスト元のエージェントがどのエディタ（Claude Code, Clineなど）であるかを識別する必要があります。しかし、MCPの仕様自体には、この識別情報を含める標準的な方法はありません。この問題に対する解決策として、MCPのツール呼び出し自体に、エージェントが自己申告するメタデータを含めることを提案します。具体的には、エージェント側のシステムプロンプトやユーザーの初期プロンプトに、「MCPサーバーを呼び出す際には、自身の識別子とバージョン情報を引数に含めること」を指示します。これにより、ツール呼び出しは以下のようになります。mcp__rules_server__setRule({ editorIdentifier: "cline", editorVersion: "3.13.0",...other_params })この自己申告メカニズムにより、サーバーはリクエストを適切なハンドラにルーティングすることが可能になります。MCPツールインターフェースの定義（JSON Schema）AIエージェントとサーバー間の通信を予測可能かつ安定させるため、ツール呼び出しの引数に対するフォーマルな契約、すなわちJSON Schemaを定義します 22。これにより、エージェントは常に正しい形式でリクエストを送信することが保証されます。setRuleコマンドの提案スキーマ以下は、特定のルールファイルを作成または更新するためのsetRuleコマンドのJSON Schema案です。JSON{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "SetRuleCommand",
  "description": "A command to create or update a rule file for a specific editor.",
  "type": "object",
  "properties": {
    "editorIdentifier": {
      "description": "Identifier for the target editor.",
      "type": "string",
      "enum": ["claude-code", "cline", "roo-code", "unknown"]
    },
    "workspacePath": {
      "description": "The absolute path to the root of the project workspace on the client machine.",
      "type": "string"
    },
    "rule": {
      "description": "The rule object to be set.",
      "type": "object",
      "properties": {
        "relativePath": {
          "description": "The path of the rule file relative to the workspace root (e.g., '.clinerules/01-main.md').",
          "type": "string"
        },
        "content": {
          "description": "The full text content of the rule file's body (Markdown part).",
          "type": "string"
        },
        "metadata": {
          "description": "Optional structured metadata for formats like TOML. This will be serialized as frontmatter.",
          "type": "object"
        }
      },
      "required": ["relativePath", "content"]
    }
  },
  "required": ["editorIdentifier", "workspacePath", "rule"]
}
エディタ特化型ハンドラの実装戦略（プラグインアーキテクチャ）サーバーの中核には、エディタごとに特化した処理ロジックを持つハンドラを動的に切り替えるプラグインアーキテクチャを採用します。ハンドラインターフェースまず、すべてのエディタハンドラが実装すべき共通のインターフェースをTypeScriptで定義します。TypeScriptinterface IEditorRuleHandler {
  handleSetRule(command: SetRuleCommand): Promise<{success: boolean; message: string;}>;
  // 将来的には handleGetRule, handleDeleteRule などのメソッドも追加可能
}
ClaudeCodeHandlerの実装このハンドラはIEditorRuleHandlerを実装します。内部では、@anthropic-ai/claude-code Node.js SDKを利用します 11。handleSetRuleメソッドは、受け取ったコマンドから「指定されたパス...に、指定された内容...でファイルを書き込め」という自然言語プロンプトを構築します。このプロンプトを、適切なcwd（作業ディレクトリ）、allowed_tools（["Write"]）、そしてpermission_mode（非対話モード）を設定した上で、SDKのquery()関数を用いて実行します。この方法は、公式SDKに依存するため、最も堅牢で信頼性が高い実装となります。ClineHandlerおよびRooCodeHandlerの実装これらのハンドラもIEditorRuleHandlerを実装します。内部では、Node.jsの組み込みモジュールであるfs/promisesを使用して、ファイルシステムを直接操作します。ロジックは以下の手順を慎重に実行する必要があります。絶対パスの解決: path.join(command.workspacePath, command.rule.relativePath)ディレクトリの存在確認と作成: fs.mkdir(path.dirname(absolutePath), { recursive: true })ファイル内容の書き込み: RooCodeHandlerの場合、command.rule.metadataオブジェクトをTOMLフロントマター形式の文字列にシリアライズし、command.rule.contentの先頭に結合する処理が必要です。エラーハンドリング: ファイルシステムのパーミッションエラーやディスク容量不足といった問題を適切に処理します。アトミックな書き込み: 安全性を高めるため、一時ファイルに書き込んだ後、目的のファイルパスにリネームする、といったトランザクション的な操作を実装します。拡張性のためのフレームワーク新しいエディタへの対応を容易にするため、ハンドラを生成するファクトリパターンを導入します。ハンドラファクトリeditorIdentifierを引数に取り、対応するハンドラインスタンスを返すEditorHandlerFactoryを定義します。TypeScriptclass EditorHandlerFactory {
  public static getHandler(editorIdentifier: string): IEditorRuleHandler {
    switch (editorIdentifier) {
      case 'claude-code':
        return new ClaudeCodeHandler();
      case 'cline':
        return new ClineHandler();
      case 'roo-code':
        return new RooCodeHandler();
      default:
        // 未知のエディタに対応するためのデフォルトハンドラやエラー処理
        throw new Error(`Unsupported editor: ${editorIdentifier}`);
    }
  }
}
この設計により、新しいエディタ（例：NewEditor）をサポートするには、IEditorRuleHandlerインターフェースを実装したNewEditorHandlerクラスを作成し、ファクトリのswitch文に一行追加するだけで済みます。これにより、システムはクリーンで疎結合、かつ高い拡張性を維持できます。ワークフロー例以下に、ClineエージェントがMCPサーバーを利用してルールを設定する際の処理フローを記述します。ユーザーが**AIエージェント（Cline）**にプロンプトを入力：「このプロジェクトに標準のTypeScriptルールを適用して。」AIエージェントは、内蔵された指示に基づき、MCPサーバーへのツール呼び出しを定式化：mcp__rules_server__setRule({ editorIdentifier: 'cline', workspacePath: '/path/to/project', rule: {... } })MCPルールサーバーがこのリクエストを受信します。サーバーのメインコントローラがEditorHandlerFactory.getHandler('cline')を呼び出し、ClineHandlerのインスタンスを取得します。コントローラは取得したハンドラのhandleSetRule(command)メソッドを呼び出します。ClineHandlerはファイルシステム操作を実行し、クライアントマシンのファイルシステム上に.clinerules/standard-ts.mdファイルを作成・書き込みします。ClineHandlerは成功を示すレスポンスをサーバーコントローラに返します。MCPルールサーバーは、成功したtool_resultをAIエージェントに返します。AIエージェントは、処理の完了をユーザーに報告：「標準のTypeScriptルールを適用しました。」結論：中央集権的なAIガバナンスによるワークフローの一貫性達成本報告書では、Claude Code、Cline、Roo Codeという3つの主要なAIコーディングアシスタントにおけるルール管理メカニズムを詳細に分析しました。その結果、Claude Codeが公式SDKを介したAPI駆動型のアプローチを取る一方で、ClineとRoo Codeはファイルシステム規約に依存するファイル中心のモデルを採用しているという、根本的な違いが明らかになりました。しかし、すべてのツールに共通しているのは、バージョン管理が可能で、プロジェクトにローカルなテキストベースのルールファイルを重視する傾向です。これらの分析に基づき提案されたMCPサーバーのアーキテクチャは、各エディタの実装詳細を抽象化し、一元的な制御点を提供します。エディタ識別子を含むツール呼び出し規約、JSON Schemaによる厳密なインターフェース定義、そしてプラグイン可能なハンドラアーキテクチャにより、システムは高い信頼性、保守性、拡張性を実現します。特に、ClaudeCodeHandlerは公式SDKを利用することで最も堅牢な実装となり、ファイルシステムを直接操作するClineHandlerやRooCodeHandlerは、より慎重なエラーハンドリングとトランザクション管理が求められます。この中央集権的なルール管理サーバーを導入することにより、組織は以下のような戦略的利点を享受できます。一貫性の確保: 開発チーム全体で、使用するAIアシスタントの種類に関わらず、統一されたコーディング規約やセキュリティポリシーを強制できます。セキュリティの向上: 安全でないコマンドの実行を禁止するルールなどを一元的に配布し、AIエージェントによる意図しないシステム変更のリスクを低減します。開発者体験の向上: 開発者は、プロジェクトごとに手動でルールを設定する手間から解放され、より本質的な開発作業に集中できます。迅速な標準展開: 新しいコーディング標準やベストプラクティスを、サーバーの設定を更新するだけで組織全体に迅速に展開できます。結論として、提案するMCPサーバーアーキテクチャは、多様化するAI搭載ツールのエコシステムにおいて、開発ワークフローのガバナンスを確立し、その価値と安全性を最大化するための、現実的かつ強力なソリューションです。